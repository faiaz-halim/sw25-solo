Project Requirement Document (PRD)
1. Project Vision & Introduction
To create a single-player, isometric RPG experience that faithfully adapts the Japanese tabletop RPG "Sword World 2.5." The game will leverage a powerful AI backbone (OpenRouter) to act as a dynamic Game Master (GM). This AI GM will procedurally generate a unique world, engaging quests, and rich, reactive stories for the player. The primary goal is to offer a deeply personal and replayable adventure that captures the essence of a TTRPG session, complete with AI-driven party members who have distinct personalities.
The project will be developed in two main phases:

Phase 1: A fully functional game with a web-based chat interface to prove the core mechanics and AI integration.
Phase 2: The development of an isometric Godot 4 client to provide a rich visual experience, integrated with the established backend.

2. Core Features

AI Game Master: The system will serve as the game master, strictly adhering to the Sword World 2.5 ruleset. It will describe environments, control NPCs, present challenges, and react to player choices in real-time.
Procedural Content Generation (PCG): The game world, its history, quests, dungeons, and stories will be randomly and procedurally generated by the AI at the start of and throughout the game, ensuring no two playthroughs are the same.
Faithful Rule Implementation: All game mechanics, including character creation, attributes, skill checks, combat, and magic, will be based on the provided Sword World 2.5 Core Rulebook.
Dynamic Character Creation: Players will create their unique protagonist by making a few key selections. The AI will then generate a detailed origin story based on these choices and rolls from the rulebook's "History Table" [p. 52]. This backstory will directly influence the character's starting attributes and potential penalties or bonuses.
AI-Powered Party Members: The world will be populated with a roster of procedurally generated characters. Players can recruit these characters into their party. Each party member will possess a unique, AI-driven personality, background, and motivation, allowing them to offer advice, interact with the world, and assist the player in intuitive ways.
Phased Development: The initial version will be a web-based chat game, focusing on the narrative and rules engine. A Godot-based isometric client will be built upon this foundation for a full visual implementation.

3. Target Audience

Fans of the Sword World TTRPG series.
Players of JRPGs and CRPGs looking for a deep, story-driven experience.
TTRPG players seeking a single-player experience that emulates playing with a human GM.
Gamers interested in emergent narratives and procedurally generated worlds.

4. High-Level System Architecture
The system will be built on a client-server model to separate the game logic and AI processing from the player-facing interface.

Player Interface (Frontend): This is what the player interacts with. Initially a web browser (Phase 1), later a Godot 4 game client (Phase 2).
Game Logic Server (Backend): The central hub of the game. It will house the Sword World 2.5 rules engine, manage the game state, and process player actions.
AI Service (External API): The OpenRouter LLM API will be called by the backend to generate all creative content, including narrative text, character backstories, quest details, and NPC dialogue.

5. Technical Stack

AI Backbone: OpenRouter API (providing access to various LLMs).
Backend Server: Python with a web framework like FastAPI or Flask (for handling game logic and API communication).
Phase 1 Frontend: Standard Web Technologies (HTML, CSS, JavaScript).
Phase 2 Frontend: Godot Engine 4 with GDScript.

Detailed Implementation Document
Module 1: Core Game Logic & Rules Engine (Backend)
This module is the non-AI foundation of the game, ensuring strict adherence to the TTRPG rules.

Technology: Python.
Implementation Details:
Data Models: Create Python classes for all core game concepts: Character, Race, Class, Skill, Spell, Item, Monster, Quest, etc. These classes will hold the attributes and methods defined in the Sword World 2.5 rulebook.
Character Sheet Logic: Implement the character sheet [p. 56] as a primary data structure. This includes attributes (Dexterity, Strength, etc.), combat stats (HP, MP, Defense), and skills.
Ruleset Implementation: Code the core game loops and functions:
create_character(): A function to guide the player through race, class, and background selection.
roll_dice(notation): A utility to handle all dice rolls (e.g., '2d6+3').
skill_check(character, skill, difficulty): A function to perform skill checks according to the rules.
combat_manager(): A turn-based system to handle combat, including initiative, actions (attack, defend, spellcast), damage calculation, and status effects.

Game State Management: Maintain the entire state of the game world in memory or a database. This includes the player's party composition, inventory, location, active quests, and world-specific flags that change based on player actions.

Module 2: AI Game Master & Content Generation (Backend)
This module interfaces with OpenRouter to breathe life into the game world.

Technology: Python, OpenRouter API.
Implementation Details:
Prompt Engineering: This is the most critical aspect. Develop a library of structured prompts for the LLM.
World Generation Prompt: At the start of a new game, send a prompt to generate a description of the starting region within the "Alframe Continent" [p. 440], including its name, major settlements, key geographical features, and a central conflict or mystery.
Character Background Prompt: Take the player's initial choices and the results of the "History Table A" [p. 52] as input. The prompt will ask the LLM to weave these elements into a cohesive 3-4 paragraph backstory. The response will be parsed to identify keywords that might grant specific starting bonuses or penalties.
Quest Generation Prompt: When a quest is needed, send the current game state (party level, location, recent events) to the LLM. The prompt will request a quest structured like the sample scenario [p. 364], with an overview, setting, key scenes, and potential outcomes.
GM Action Prompt: During gameplay, the player's text input ("I search the room for traps") will be sent to the LLM within a larger context prompt that includes the current scene description and character states. The LLM's response will be the narrative description of the outcome.

API Interaction:
Create a dedicated Python module to handle all calls to the OpenRouter API.
Implement error handling for API failures and retries.
Parse the JSON responses from the LLM to extract the narrative text and any structured data (like quest objectives or NPC stats).

Module 3: API Server (Backend-Frontend Bridge)
This is the communication layer between the frontend client and the backend logic.

Technology: Python with FastAPI or Flask.
Implementation Details:
RESTful Endpoints:
POST /api/game/new: Initializes a new game session. Calls the character and world generation modules. Returns the initial game state.
POST /api/game/{session_id}/action: Receives a player action (e.g., { "action_type": "text", "value": "I ask the bartender for rumors" }). It passes the action to the game logic and AI modules, waits for the result, updates the game state, and returns the narrative outcome and new state.
GET /api/game/{session_id}/state: Allows the client to request the full, up-to-date game state at any time.

Module 4: Web-Based Chat Interface (Phase 1 Frontend)
A lightweight client to test and play the core game.

Technology: HTML, CSS, JavaScript.
Implementation Details:
UI Layout:
Narrative Window: A large, scrollable div to display the GM's descriptions.
Input Box: A text input field for the player to type their commands.
Character Sheet Panel: A sidebar that dynamically displays the player's character sheet by fetching data from the backend.
Party Panel: A section to show the status of current party members.

Functionality:
Use the JavaScript fetch API to communicate with the backend's RESTful endpoints.
When the player submits an action, POST it to the /action endpoint.
On receiving a response, append the narrative text to the main window and update the character/party panels with the new game state data.

Module 5: Godot Isometric Client (Phase 2 Frontend)
The full visual implementation of the game.

Technology: Godot 4, GDScript.
Implementation Details:
World Rendering: Use Godot's TileMap node with an isometric tile set to visually represent the game world. Levels and areas can be procedurally assembled based on descriptions from the AI GM.
Character Representation: Create animated CharacterBody2D scenes for the player and NPCs. Their movement and actions will be driven by data received from the backend.
UI/UX: Recreate the chat and character sheet UI elements using Godot's Control nodes. Player input will be a hybrid of clicking on the map to move/interact and using the chat window for complex actions and dialogue.
Backend Communication: Use Godot's built-in HTTPRequest node to make calls to the backend API. The client will send player actions and periodically poll for game state updates to keep the visual representation in sync with the server's state.